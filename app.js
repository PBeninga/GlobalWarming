var express = require('express');
//require p2 physics library in the server.
var p2 = require('p2');

var app = express();
var serv = require('http').Server(app);
//get the functions required to move players in the server.
var physicsPlayer = require('./server/physics/playermovement.js');

app.get('/',function(req, res) {
	res.sendFile(__dirname + '/client/index.html');
});
app.use('/client',express.static(__dirname + '/client'));

serv.listen(process.env.PORT || 2000);
console.log("Server started.");

var player_list = [];

//needed for physics update
var startTime = (new Date).getTime();
var lastTime;
var timeStep= 1/70;

//the physics world in the server. This is where all the physics happens.
//we set gravity to 0 since we are just following mouse pointers.
var world = new p2.World({
  gravity : [0,0]
});

//a player class in the server
var Player = function (startX, startY, startAngle) {
  this.x = startX
  this.y = startY
  this.angle = startAngle
  this.speed = 500;
  //We need to intilaize with true.
  this.sendData = true;
}

//We call physics handler 60fps. The physics is calculated here.
setInterval(physics_hanlder, 1000/60);

//Steps the physics world.
function physics_hanlder() {
	var currentTime = (new Date).getTime();
	timeElapsed = currentTime - startTime;
	var dt = lastTime ? (timeElapsed - lastTime) / 1000 : 0;
    dt = Math.min(1 / 10, dt);
    world.step(timeStep);
}


// when a new player connects, we make a new instance of the player object,
// and send a new player message to the client.
function onNewplayer (data) {
	console.log(data);
	//new player instance
	var newPlayer = new Player(data.x, data.y, data.angle);

	//create an instance of player body
	playerBody = new p2.Body ({
		mass: 0,
		position: [0,0],
		fixedRotation: true
	});

	//add the playerbody into the player object
	newPlayer.playerBody = playerBody;
	world.addBody(newPlayer.playerBody);

	console.log("created new player with id " + this.id);
	newPlayer.id = this.id;
	//information to be sent to all clients except sender
	var current_info = {
		id: newPlayer.id,
		x: newPlayer.x,
		y: newPlayer.y,
		angle: newPlayer.angle,
	};

	//send to the new player about everyone who is already connected.
	for (i = 0; i < player_list.length; i++) {
		existingPlayer = player_list[i];
		var player_info = {
			id: existingPlayer.id,
			x: existingPlayer.x,
			y: existingPlayer.y,
			angle: existingPlayer.angle,
		};
		console.log("pushing player");
		//send message to the sender-client only
		this.emit("new_enemyPlayer", player_info);
	}

	//send message to every connected client except the sender
	this.broadcast.emit('new_enemyPlayer', current_info);


	player_list.push(newPlayer);
}


//we're not using this anymore
function onMovePlayer (data) {
	var movePlayer = find_playerid(this.id);
	movePlayer.x = data.x;
	movePlayer.y = data.y;
	movePlayer.angle = data.angle;

	var moveplayerData = {
		id: movePlayer.id,
		x: movePlayer.x,
		y: movePlayer.y,
		angle: movePlayer.angle
	}

	//send message to every connected client except the sender
	this.broadcast.emit('enemy_move', moveplayerData);
}

//instead of listening to player positions, we listen to user inputs
function onInputFired (data) {
	var movePlayer = find_playerid(this.id, this.room);


	if (!movePlayer) {
		return;
		console.log('no player');
	}

	//when sendData is true, we send the data back to client.
	if (!movePlayer.sendData) {
		return;
	}

	//every 50ms, we send the data.
	setTimeout(function() {movePlayer.sendData = true}, 50);
	//we set sendData to false when we send the data.
	movePlayer.sendData = false;

	//Make a new pointer with the new inputs from the client.
	//contains player positions in server
	var serverPointer = {
		x: data.pointer_x,
		y: data.pointer_y,
		worldX: data.pointer_worldx,
		worldY: data.pointer_worldy
	}

	//moving the player to the new inputs from the player
	if (physicsPlayer.distanceToPointer(movePlayer, serverPointer) <= 30) {
		movePlayer.playerBody.angle = physicsPlayer.movetoPointer(movePlayer, 0, serverPointer, 1000);
	} else {
		movePlayer.playerBody.angle = physicsPlayer.movetoPointer(movePlayer, movePlayer.speed, serverPointer);
	}

	//new player position to be sent back to client.
	var info = {
		x: movePlayer.playerBody.position[0],
		y: movePlayer.playerBody.position[1],
		angle: movePlayer.playerBody.angle
	}

	//send to sender (not to every clients).
	this.emit('input_recieved', info);

	//data to be sent back to everyone except sender
	var moveplayerData = {
		id: movePlayer.id,
		x: movePlayer.playerBody.position[0],
		y: movePlayer.playerBody.position[1],
		angle: movePlayer.playerBody.angle,
	}

	//send to everyone except sender
	this.broadcast.emit('enemy_move', moveplayerData);
}

//call when a client disconnects and tell the clients except sender to remove the disconnected player
function onClientdisconnect() {
	console.log('disconnect');

	var removePlayer = find_playerid(this.id);

	if (removePlayer) {
		player_list.splice(player_list.indexOf(removePlayer), 1);
	}

	console.log("removing player " + this.id);

	//send message to every connected client except the sender
	this.broadcast.emit('remove_player', {id: this.id});

}

// find player by the the unique socket id
function find_playerid(id) {

	for (var i = 0; i < player_list.length; i++) {

		if (player_list[i].id == id) {
			return player_list[i];
		}
	}

	return false;
}

 // io connection
var io = require('socket.io')(serv,{});

io.sockets.on('connection', function(socket){
	console.log("socket connected");

	// listen for disconnection;
	socket.on('disconnect', onClientdisconnect);

	// listen for new player
	socket.on("new_player", onNewplayer);
	/*
	//we dont need this anymore
	socket.on("move_player", onMovePlayer);
	*/
	//listen for new player inputs.
	socket.on("input_fired", onInputFired);
});
